// Code generated by Prisma Client Go. DO NOT EDIT.
//nolint
//go:build !codeanalysis
// +build !codeanalysis

package db

import (
	"context"
	"testing"

	"github.com/prisma/prisma-client-go/engine"
	"github.com/prisma/prisma-client-go/engine/mock"
	"github.com/prisma/prisma-client-go/runtime/builder"
	"github.com/prisma/prisma-client-go/runtime/lifecycle"
	"github.com/prisma/prisma-client-go/runtime/raw"
	"github.com/prisma/prisma-client-go/runtime/transaction"
	"github.com/prisma/prisma-client-go/runtime/types"

	// no-op import for go modules
	_ "github.com/iancoleman/strcase"
	_ "github.com/joho/godotenv"
	_ "github.com/shopspring/decimal"
	_ "github.com/takuoki/gocase"
)

// re-declare variables which are needed in Prisma Client Go but also should be exported
// in the generated client

const RFC3339Milli = types.RFC3339Milli

type BatchResult = types.BatchResult

type DateTime = types.DateTime
type JSON = types.JSON
type Bytes = types.Bytes
type BigInt = types.BigInt
type Decimal = types.Decimal

// deprecated: use SortOrder
type Direction = SortOrder

const (
	// deprecated: use SortOrderAsc
	ASC Direction = "asc"
	// deprecated: use SortOrderDesc
	DESC Direction = "desc"
)

// --- template actions.gotpl ---
var countOutput = []builder.Output{
	{Name: "count"},
}

type usersActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var usersOutput = []builder.Output{
	{Name: "id"},
	{Name: "firstName"},
	{Name: "lastName"},
	{Name: "email"},
	{Name: "password"},
	{Name: "accessLevel"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
}

type iUsersRelationWith interface {
	getQuery() builder.Query
	with()
	usersRelation()
}

type UsersWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
}

type usersDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersDefaultParam) field() builder.Field {
	return p.data
}

func (p usersDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p usersDefaultParam) usersModel() {}

type iUsersOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
}

type usersOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersOrderByParam) field() builder.Field {
	return p.data
}

func (p usersOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p usersOrderByParam) usersModel() {}

type iUsersCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	isCursor()
}

type usersCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersCursorParam) field() builder.Field {
	return p.data
}

func (p usersCursorParam) isCursor() {}

func (p usersCursorParam) getQuery() builder.Query {
	return p.query
}

func (p usersCursorParam) usersModel() {}

type UsersParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	usersModel()
}

type usersParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p usersParamUnique) usersModel() {}

func (usersParamUnique) unique() {}

func (p usersParamUnique) field() builder.Field {
	return p.data
}

func (p usersParamUnique) getQuery() builder.Query {
	return p.query
}

type UsersEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
}

type usersEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersEqualsParam) usersModel() {}

func (usersEqualsParam) equals() {}

func (p usersEqualsParam) field() builder.Field {
	return p.data
}

func (p usersEqualsParam) getQuery() builder.Query {
	return p.query
}

type UsersEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	usersModel()
}

type usersEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersEqualsUniqueParam) usersModel() {}

func (usersEqualsUniqueParam) unique() {}
func (usersEqualsUniqueParam) equals() {}

func (p usersEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type UsersSetParam interface {
	field() builder.Field
	settable()
	usersModel()
}

type usersSetParam struct {
	data builder.Field
}

func (usersSetParam) settable() {}

func (p usersSetParam) field() builder.Field {
	return p.data
}

func (p usersSetParam) usersModel() {}

type UsersWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	idField()
}

type UsersWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	idField()
}

type usersWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaIDSetParam) usersModel() {}

func (p usersWithPrismaIDSetParam) idField() {}

type UsersWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	idField()
}

type usersWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaIDEqualsParam) usersModel() {}

func (p usersWithPrismaIDEqualsParam) idField() {}

func (usersWithPrismaIDSetParam) settable()  {}
func (usersWithPrismaIDEqualsParam) equals() {}

type usersWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaIDEqualsUniqueParam) usersModel() {}
func (p usersWithPrismaIDEqualsUniqueParam) idField()    {}

func (usersWithPrismaIDEqualsUniqueParam) unique() {}
func (usersWithPrismaIDEqualsUniqueParam) equals() {}

type UsersWithPrismaFirstNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	firstNameField()
}

type UsersWithPrismaFirstNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	firstNameField()
}

type usersWithPrismaFirstNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaFirstNameSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaFirstNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaFirstNameSetParam) usersModel() {}

func (p usersWithPrismaFirstNameSetParam) firstNameField() {}

type UsersWithPrismaFirstNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	firstNameField()
}

type usersWithPrismaFirstNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaFirstNameEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaFirstNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaFirstNameEqualsParam) usersModel() {}

func (p usersWithPrismaFirstNameEqualsParam) firstNameField() {}

func (usersWithPrismaFirstNameSetParam) settable()  {}
func (usersWithPrismaFirstNameEqualsParam) equals() {}

type usersWithPrismaFirstNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaFirstNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaFirstNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaFirstNameEqualsUniqueParam) usersModel()     {}
func (p usersWithPrismaFirstNameEqualsUniqueParam) firstNameField() {}

func (usersWithPrismaFirstNameEqualsUniqueParam) unique() {}
func (usersWithPrismaFirstNameEqualsUniqueParam) equals() {}

type UsersWithPrismaLastNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	lastNameField()
}

type UsersWithPrismaLastNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	lastNameField()
}

type usersWithPrismaLastNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaLastNameSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaLastNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaLastNameSetParam) usersModel() {}

func (p usersWithPrismaLastNameSetParam) lastNameField() {}

type UsersWithPrismaLastNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	lastNameField()
}

type usersWithPrismaLastNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaLastNameEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaLastNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaLastNameEqualsParam) usersModel() {}

func (p usersWithPrismaLastNameEqualsParam) lastNameField() {}

func (usersWithPrismaLastNameSetParam) settable()  {}
func (usersWithPrismaLastNameEqualsParam) equals() {}

type usersWithPrismaLastNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaLastNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaLastNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaLastNameEqualsUniqueParam) usersModel()    {}
func (p usersWithPrismaLastNameEqualsUniqueParam) lastNameField() {}

func (usersWithPrismaLastNameEqualsUniqueParam) unique() {}
func (usersWithPrismaLastNameEqualsUniqueParam) equals() {}

type UsersWithPrismaEmailEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	emailField()
}

type UsersWithPrismaEmailSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	emailField()
}

type usersWithPrismaEmailSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaEmailSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaEmailSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaEmailSetParam) usersModel() {}

func (p usersWithPrismaEmailSetParam) emailField() {}

type UsersWithPrismaEmailWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	emailField()
}

type usersWithPrismaEmailEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaEmailEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaEmailEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaEmailEqualsParam) usersModel() {}

func (p usersWithPrismaEmailEqualsParam) emailField() {}

func (usersWithPrismaEmailSetParam) settable()  {}
func (usersWithPrismaEmailEqualsParam) equals() {}

type usersWithPrismaEmailEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaEmailEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaEmailEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaEmailEqualsUniqueParam) usersModel() {}
func (p usersWithPrismaEmailEqualsUniqueParam) emailField() {}

func (usersWithPrismaEmailEqualsUniqueParam) unique() {}
func (usersWithPrismaEmailEqualsUniqueParam) equals() {}

type UsersWithPrismaPasswordEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	passwordField()
}

type UsersWithPrismaPasswordSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	passwordField()
}

type usersWithPrismaPasswordSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaPasswordSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaPasswordSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaPasswordSetParam) usersModel() {}

func (p usersWithPrismaPasswordSetParam) passwordField() {}

type UsersWithPrismaPasswordWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	passwordField()
}

type usersWithPrismaPasswordEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaPasswordEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaPasswordEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaPasswordEqualsParam) usersModel() {}

func (p usersWithPrismaPasswordEqualsParam) passwordField() {}

func (usersWithPrismaPasswordSetParam) settable()  {}
func (usersWithPrismaPasswordEqualsParam) equals() {}

type usersWithPrismaPasswordEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaPasswordEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaPasswordEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaPasswordEqualsUniqueParam) usersModel()    {}
func (p usersWithPrismaPasswordEqualsUniqueParam) passwordField() {}

func (usersWithPrismaPasswordEqualsUniqueParam) unique() {}
func (usersWithPrismaPasswordEqualsUniqueParam) equals() {}

type UsersWithPrismaAccessLevelEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	accessLevelField()
}

type UsersWithPrismaAccessLevelSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	accessLevelField()
}

type usersWithPrismaAccessLevelSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaAccessLevelSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaAccessLevelSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaAccessLevelSetParam) usersModel() {}

func (p usersWithPrismaAccessLevelSetParam) accessLevelField() {}

type UsersWithPrismaAccessLevelWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	accessLevelField()
}

type usersWithPrismaAccessLevelEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaAccessLevelEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaAccessLevelEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaAccessLevelEqualsParam) usersModel() {}

func (p usersWithPrismaAccessLevelEqualsParam) accessLevelField() {}

func (usersWithPrismaAccessLevelSetParam) settable()  {}
func (usersWithPrismaAccessLevelEqualsParam) equals() {}

type usersWithPrismaAccessLevelEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaAccessLevelEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaAccessLevelEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaAccessLevelEqualsUniqueParam) usersModel()       {}
func (p usersWithPrismaAccessLevelEqualsUniqueParam) accessLevelField() {}

func (usersWithPrismaAccessLevelEqualsUniqueParam) unique() {}
func (usersWithPrismaAccessLevelEqualsUniqueParam) equals() {}

type UsersWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	createdAtField()
}

type UsersWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	createdAtField()
}

type usersWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaCreatedAtSetParam) usersModel() {}

func (p usersWithPrismaCreatedAtSetParam) createdAtField() {}

type UsersWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	createdAtField()
}

type usersWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaCreatedAtEqualsParam) usersModel() {}

func (p usersWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (usersWithPrismaCreatedAtSetParam) settable()  {}
func (usersWithPrismaCreatedAtEqualsParam) equals() {}

type usersWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaCreatedAtEqualsUniqueParam) usersModel()     {}
func (p usersWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (usersWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (usersWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type UsersWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	updatedAtField()
}

type UsersWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	updatedAtField()
}

type usersWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaUpdatedAtSetParam) usersModel() {}

func (p usersWithPrismaUpdatedAtSetParam) updatedAtField() {}

type UsersWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	updatedAtField()
}

type usersWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaUpdatedAtEqualsParam) usersModel() {}

func (p usersWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (usersWithPrismaUpdatedAtSetParam) settable()  {}
func (usersWithPrismaUpdatedAtEqualsParam) equals() {}

type usersWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaUpdatedAtEqualsUniqueParam) usersModel()     {}
func (p usersWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (usersWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (usersWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

// --- template create.gotpl ---

// Creates a single users.
func (r usersActions) CreateOne(
	_firstName UsersWithPrismaFirstNameSetParam,
	_lastName UsersWithPrismaLastNameSetParam,
	_email UsersWithPrismaEmailSetParam,
	_password UsersWithPrismaPasswordSetParam,

	optional ...UsersSetParam,
) usersCreateOne {
	var v usersCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Users"
	v.query.Outputs = usersOutput

	var fields []builder.Field

	fields = append(fields, _firstName.field())
	fields = append(fields, _lastName.field())
	fields = append(fields, _email.field())
	fields = append(fields, _password.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r usersCreateOne) With(params ...iUsersRelationWith) usersCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type usersCreateOne struct {
	query builder.Query
}

func (p usersCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p usersCreateOne) usersModel() {}

func (r usersCreateOne) Exec(ctx context.Context) (*UsersModel, error) {
	var v UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersCreateOne) Tx() usersUniqueTxResult {
	v := NewusersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template find.gotpl ---

type usersFindUnique struct {
	query builder.Query
}

func (r usersFindUnique) getQuery() builder.Query {
	return r.query
}

func (r usersFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r usersFindUnique) with()          {}
func (r usersFindUnique) usersModel()    {}
func (r usersFindUnique) usersRelation() {}

func (r usersActions) FindUnique(
	params UsersEqualsUniqueWhereParam,
) usersFindUnique {
	var v usersFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Users"
	v.query.Outputs = usersOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r usersFindUnique) With(params ...iUsersRelationWith) usersFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usersFindUnique) Exec(ctx context.Context) (
	*UsersModel,
	error,
) {
	var v *UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usersFindUnique) ExecInner(ctx context.Context) (
	*InnerUsers,
	error,
) {
	var v *InnerUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usersFindUnique) Update(params ...UsersSetParam) usersUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Users"

	var v usersUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type usersUpdateUnique struct {
	query builder.Query
}

func (r usersUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r usersUpdateUnique) usersModel() {}

func (r usersUpdateUnique) Exec(ctx context.Context) (*UsersModel, error) {
	var v UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersUpdateUnique) Tx() usersUniqueTxResult {
	v := NewusersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r usersFindUnique) Delete() usersDeleteUnique {
	var v usersDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Users"

	return v
}

type usersDeleteUnique struct {
	query builder.Query
}

func (r usersDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p usersDeleteUnique) usersModel() {}

func (r usersDeleteUnique) Exec(ctx context.Context) (*UsersModel, error) {
	var v UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersDeleteUnique) Tx() usersUniqueTxResult {
	v := NewusersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type usersFindFirst struct {
	query builder.Query
}

func (r usersFindFirst) getQuery() builder.Query {
	return r.query
}

func (r usersFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r usersFindFirst) with()          {}
func (r usersFindFirst) usersModel()    {}
func (r usersFindFirst) usersRelation() {}

func (r usersActions) FindFirst(
	params ...UsersWhereParam,
) usersFindFirst {
	var v usersFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Users"
	v.query.Outputs = usersOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name: "where",
			Fields: []builder.Field{
				{
					Name:     "AND",
					List:     true,
					WrapList: true,
					Fields:   where,
				},
			},
		})
	}

	return v
}

func (r usersFindFirst) With(params ...iUsersRelationWith) usersFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usersFindFirst) OrderBy(params ...iUsersOrderByParam) usersFindFirst {
	var fields []builder.Field

	for _, param := range params {
		direction, _ := param.field().Value.(SortOrder)

		fields = append(fields, builder.Field{
			Name:  param.field().Name,
			Value: direction,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "orderBy",
		Fields: fields,
	})

	return r
}

func (r usersFindFirst) Skip(count int) usersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r usersFindFirst) Take(count int) usersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r usersFindFirst) Cursor(cursor iUsersCursorParam) usersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r usersFindFirst) Exec(ctx context.Context) (
	*UsersModel,
	error,
) {
	var v *UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usersFindFirst) ExecInner(ctx context.Context) (
	*InnerUsers,
	error,
) {
	var v *InnerUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type usersFindMany struct {
	query builder.Query
}

func (r usersFindMany) getQuery() builder.Query {
	return r.query
}

func (r usersFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r usersFindMany) with()          {}
func (r usersFindMany) usersModel()    {}
func (r usersFindMany) usersRelation() {}

func (r usersActions) FindMany(
	params ...UsersWhereParam,
) usersFindMany {
	var v usersFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Users"
	v.query.Outputs = usersOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name: "where",
			Fields: []builder.Field{
				{
					Name:     "AND",
					List:     true,
					WrapList: true,
					Fields:   where,
				},
			},
		})
	}

	return v
}

func (r usersFindMany) With(params ...iUsersRelationWith) usersFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usersFindMany) OrderBy(params ...iUsersOrderByParam) usersFindMany {
	var fields []builder.Field

	for _, param := range params {
		direction, _ := param.field().Value.(SortOrder)

		fields = append(fields, builder.Field{
			Name:  param.field().Name,
			Value: direction,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "orderBy",
		Fields: fields,
	})

	return r
}

func (r usersFindMany) Skip(count int) usersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r usersFindMany) Take(count int) usersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r usersFindMany) Cursor(cursor iUsersCursorParam) usersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r usersFindMany) Exec(ctx context.Context) (
	[]UsersModel,
	error,
) {
	var v []UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r usersFindMany) ExecInner(ctx context.Context) (
	[]InnerUsers,
	error,
) {
	var v []InnerUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r usersFindMany) Update(params ...UsersSetParam) usersUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Users"

	r.query.Outputs = countOutput

	var v usersUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type usersUpdateMany struct {
	query builder.Query
}

func (r usersUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r usersUpdateMany) usersModel() {}

func (r usersUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersUpdateMany) Tx() usersManyTxResult {
	v := NewusersManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r usersFindMany) Delete() usersDeleteMany {
	var v usersDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Users"

	v.query.Outputs = countOutput

	return v
}

type usersDeleteMany struct {
	query builder.Query
}

func (r usersDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p usersDeleteMany) usersModel() {}

func (r usersDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersDeleteMany) Tx() usersManyTxResult {
	v := NewusersManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template transaction.gotpl ---

func NewusersUniqueTxResult() usersUniqueTxResult {
	return usersUniqueTxResult{
		result: &transaction.Result{},
	}
}

type usersUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p usersUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p usersUniqueTxResult) IsTx() {}

func (r usersUniqueTxResult) Result() (v *UsersModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewusersManyTxResult() usersManyTxResult {
	return usersManyTxResult{
		result: &transaction.Result{},
	}
}

type usersManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p usersManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p usersManyTxResult) IsTx() {}

func (r usersManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

// --- template upsert.gotpl ---

type usersUpsertOne struct {
	query builder.Query
}

func (r usersUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r usersUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r usersUpsertOne) with()          {}
func (r usersUpsertOne) usersModel()    {}
func (r usersUpsertOne) usersRelation() {}

func (r usersActions) UpsertOne(
	params UsersEqualsUniqueWhereParam,
) usersUpsertOne {
	var v usersUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Users"
	v.query.Outputs = usersOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r usersUpsertOne) Create(

	_firstName UsersWithPrismaFirstNameSetParam,
	_lastName UsersWithPrismaLastNameSetParam,
	_email UsersWithPrismaEmailSetParam,
	_password UsersWithPrismaPasswordSetParam,

	optional ...UsersSetParam,
) usersUpsertOne {
	var v usersUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _firstName.field())
	fields = append(fields, _lastName.field())
	fields = append(fields, _email.field())
	fields = append(fields, _password.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r usersUpsertOne) Update(
	params ...UsersSetParam,
) usersUpsertOne {
	var v usersUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r usersUpsertOne) Exec(ctx context.Context) (*UsersModel, error) {
	var v UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersUpsertOne) Tx() usersUniqueTxResult {
	v := NewusersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template client.gotpl ---
const schema = `datasource db {
    provider = "postgres"
    url = "postgres://pgdmn:secret@192.168.101.2:5234/bookings"
}

generator db {
    provider = "go run github.com/prisma/prisma-client-go"
}

model Users {
    id  String  @id @default(uuid())
    firstName   String
    lastName    String
    email   String
    password    String
    accessLevel Int @default(1)
    createdAt   DateTime @default(now())
    updatedAt   DateTime    @updatedAt
}`

// hasBinaryTargets is true when binaryTargets are provided on generation time
var hasBinaryTargets = false

// NewClient creates a new Prisma Client Go client.
// The client is not connected to the Prisma engine yet.
//
// Example:
//
//   client := db.NewClient()
//   if err := client.Prisma.Connect(); err != nil {
//     handle(err)
//   }
//
//   defer func() {
//     if err := client.Prisma.Disconnect(); err != nil {
//       panic(fmt.Errorf("could not disconnect: %w", err))
//     }
//   }()
func NewClient() *PrismaClient {
	c := newClient()
	c.Engine = engine.New(schema, hasBinaryTargets)
	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

func newMockClient(expectations *[]mock.Expectation) *PrismaClient {
	c := newClient()
	c.Engine = mock.New(expectations)
	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

func newClient() *PrismaClient {
	c := &PrismaClient{}
	c.Users = usersActions{client: c}

	c.Prisma = &PrismaActions{
		Raw: &raw.Raw{Engine: c},
		TX:  &transaction.TX{Engine: c},
	}
	return c
}

type PrismaActions struct {
	*lifecycle.Lifecycle
	*raw.Raw
	*transaction.TX
}

// PrismaClient is the instance of the Prisma Client Go client.
type PrismaClient struct {
	// engine is an abstractions of what happens under the hood
	// the query engine can spawn and manage the binary and send requests to it,
	// while a mock engine would collect mocks to verify them later
	engine.Engine

	// prisma provides prisma-related methods as opposed to model methods, such as Connect, Disconnect or raw queries
	Prisma *PrismaActions

	// Users provides access to CRUD methods.
	Users usersActions
}

// --- template enums.gotpl ---

type UsersScalarFieldEnum string

const (
	UsersScalarFieldEnumID          UsersScalarFieldEnum = "id"
	UsersScalarFieldEnumFirstName   UsersScalarFieldEnum = "firstName"
	UsersScalarFieldEnumLastName    UsersScalarFieldEnum = "lastName"
	UsersScalarFieldEnumEmail       UsersScalarFieldEnum = "email"
	UsersScalarFieldEnumPassword    UsersScalarFieldEnum = "password"
	UsersScalarFieldEnumAccessLevel UsersScalarFieldEnum = "accessLevel"
	UsersScalarFieldEnumCreatedAt   UsersScalarFieldEnum = "createdAt"
	UsersScalarFieldEnumUpdatedAt   UsersScalarFieldEnum = "updatedAt"
)

type SortOrder string

const (
	SortOrderAsc  SortOrder = "asc"
	SortOrderDesc SortOrder = "desc"
)

type QueryMode string

const (
	QueryModeDefault     QueryMode = "default"
	QueryModeInsensitive QueryMode = "insensitive"
)

// --- template errors.gotpl ---
var ErrNotFound = types.ErrNotFound

// --- template mock.gotpl ---
func NewMock() (*PrismaClient, *Mock, func(t *testing.T)) {
	expectations := new([]mock.Expectation)
	pc := newMockClient(expectations)
	m := &Mock{
		Mock: &mock.Mock{
			Expectations: expectations,
		},
	}

	m.Users = usersMock{
		mock: m,
	}

	return pc, m, m.Ensure
}

type Mock struct {
	*mock.Mock

	Users usersMock
}

type usersMock struct {
	mock *Mock
}

type iUsersMockExpectParam interface {
	ExtractQuery() builder.Query
	usersModel()
}

func (m *usersMock) Expect(query iUsersMockExpectParam) *usersMockExec {
	return &usersMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type usersMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *usersMockExec) Returns(v UsersModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *usersMockExec) ReturnsMany(v []UsersModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *usersMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

// --- template models.gotpl ---

// UsersModel represents the `json:"Users"` model and is a wrapper for accessing fields and methods
type UsersModel struct {
	InnerUsers
	RelationsUsers
}

// InnerUsers holds the actual data
type InnerUsers struct {
	ID          string   `json:"id"`
	FirstName   string   `json:"firstName"`
	LastName    string   `json:"lastName"`
	Email       string   `json:"email"`
	Password    string   `json:"password"`
	AccessLevel int      `json:"accessLevel"`
	CreatedAt   DateTime `json:"createdAt"`
	UpdatedAt   DateTime `json:"updatedAt"`
}

// RelationsUsers holds the relation data separately
type RelationsUsers struct {
}

// --- template query.gotpl ---

// Users acts as a namespaces to access query methods for the Users model
var Users = usersQuery{}

// usersQuery exposes query functions for the users model
type usersQuery struct {
	// ID
	//
	// @required
	ID usersQueryIDString

	// FirstName
	//
	// @required
	FirstName usersQueryFirstNameString

	// LastName
	//
	// @required
	LastName usersQueryLastNameString

	// Email
	//
	// @required
	Email usersQueryEmailString

	// Password
	//
	// @required
	Password usersQueryPasswordString

	// AccessLevel
	//
	// @required
	AccessLevel usersQueryAccessLevelInt

	// CreatedAt
	//
	// @required
	CreatedAt usersQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt usersQueryUpdatedAtDateTime
}

func (usersQuery) Not(params ...UsersWhereParam) usersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usersDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (usersQuery) Or(params ...UsersWhereParam) usersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usersDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (usersQuery) And(params ...UsersWhereParam) usersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usersDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type usersQueryIDString struct{}

// Set the required value of ID
func (r usersQueryIDString) Set(value string) usersSetParam {

	return usersSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r usersQueryIDString) SetIfPresent(value *string) usersSetParam {
	if value == nil {
		return usersSetParam{}
	}

	return r.Set(*value)
}

func (r usersQueryIDString) Equals(value string) usersWithPrismaIDEqualsUniqueParam {

	return usersWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDString) EqualsIfPresent(value *string) usersWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return usersWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryIDString) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r usersQueryIDString) Cursor(cursor string) usersCursorParam {
	return usersCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r usersQueryIDString) In(value []string) usersParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryIDString) InIfPresent(value []string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.In(value)
}

func (r usersQueryIDString) NotIn(value []string) usersParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryIDString) NotInIfPresent(value []string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.NotIn(value)
}

func (r usersQueryIDString) Lt(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDString) LtIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Lt(*value)
}

func (r usersQueryIDString) Lte(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDString) LteIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Lte(*value)
}

func (r usersQueryIDString) Gt(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDString) GtIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Gt(*value)
}

func (r usersQueryIDString) Gte(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDString) GteIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Gte(*value)
}

func (r usersQueryIDString) Contains(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDString) ContainsIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Contains(*value)
}

func (r usersQueryIDString) StartsWith(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDString) StartsWithIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r usersQueryIDString) EndsWith(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDString) EndsWithIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r usersQueryIDString) Mode(value QueryMode) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDString) ModeIfPresent(value *QueryMode) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Mode(*value)
}

func (r usersQueryIDString) Not(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIDString) NotIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r usersQueryIDString) HasPrefix(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r usersQueryIDString) HasPrefixIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r usersQueryIDString) HasSuffix(value string) usersParamUnique {

	return usersParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r usersQueryIDString) HasSuffixIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type usersQueryFirstNameString struct{}

// Set the required value of FirstName
func (r usersQueryFirstNameString) Set(value string) usersWithPrismaFirstNameSetParam {

	return usersWithPrismaFirstNameSetParam{
		data: builder.Field{
			Name:  "firstName",
			Value: value,
		},
	}

}

// Set the optional value of FirstName dynamically
func (r usersQueryFirstNameString) SetIfPresent(value *string) usersWithPrismaFirstNameSetParam {
	if value == nil {
		return usersWithPrismaFirstNameSetParam{}
	}

	return r.Set(*value)
}

func (r usersQueryFirstNameString) Equals(value string) usersWithPrismaFirstNameEqualsParam {

	return usersWithPrismaFirstNameEqualsParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryFirstNameString) EqualsIfPresent(value *string) usersWithPrismaFirstNameEqualsParam {
	if value == nil {
		return usersWithPrismaFirstNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryFirstNameString) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "firstName",
			Value: direction,
		},
	}
}

func (r usersQueryFirstNameString) In(value []string) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryFirstNameString) InIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.In(value)
}

func (r usersQueryFirstNameString) NotIn(value []string) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryFirstNameString) NotInIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usersQueryFirstNameString) Lt(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryFirstNameString) LtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usersQueryFirstNameString) Lte(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryFirstNameString) LteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usersQueryFirstNameString) Gt(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryFirstNameString) GtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usersQueryFirstNameString) Gte(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryFirstNameString) GteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usersQueryFirstNameString) Contains(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryFirstNameString) ContainsIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Contains(*value)
}

func (r usersQueryFirstNameString) StartsWith(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryFirstNameString) StartsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r usersQueryFirstNameString) EndsWith(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryFirstNameString) EndsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r usersQueryFirstNameString) Mode(value QueryMode) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryFirstNameString) ModeIfPresent(value *QueryMode) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Mode(*value)
}

func (r usersQueryFirstNameString) Not(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryFirstNameString) NotIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r usersQueryFirstNameString) HasPrefix(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r usersQueryFirstNameString) HasPrefixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r usersQueryFirstNameString) HasSuffix(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r usersQueryFirstNameString) HasSuffixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type usersQueryLastNameString struct{}

// Set the required value of LastName
func (r usersQueryLastNameString) Set(value string) usersWithPrismaLastNameSetParam {

	return usersWithPrismaLastNameSetParam{
		data: builder.Field{
			Name:  "lastName",
			Value: value,
		},
	}

}

// Set the optional value of LastName dynamically
func (r usersQueryLastNameString) SetIfPresent(value *string) usersWithPrismaLastNameSetParam {
	if value == nil {
		return usersWithPrismaLastNameSetParam{}
	}

	return r.Set(*value)
}

func (r usersQueryLastNameString) Equals(value string) usersWithPrismaLastNameEqualsParam {

	return usersWithPrismaLastNameEqualsParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryLastNameString) EqualsIfPresent(value *string) usersWithPrismaLastNameEqualsParam {
	if value == nil {
		return usersWithPrismaLastNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryLastNameString) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "lastName",
			Value: direction,
		},
	}
}

func (r usersQueryLastNameString) In(value []string) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryLastNameString) InIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.In(value)
}

func (r usersQueryLastNameString) NotIn(value []string) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryLastNameString) NotInIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usersQueryLastNameString) Lt(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryLastNameString) LtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usersQueryLastNameString) Lte(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryLastNameString) LteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usersQueryLastNameString) Gt(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryLastNameString) GtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usersQueryLastNameString) Gte(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryLastNameString) GteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usersQueryLastNameString) Contains(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryLastNameString) ContainsIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Contains(*value)
}

func (r usersQueryLastNameString) StartsWith(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryLastNameString) StartsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r usersQueryLastNameString) EndsWith(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryLastNameString) EndsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r usersQueryLastNameString) Mode(value QueryMode) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryLastNameString) ModeIfPresent(value *QueryMode) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Mode(*value)
}

func (r usersQueryLastNameString) Not(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryLastNameString) NotIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r usersQueryLastNameString) HasPrefix(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r usersQueryLastNameString) HasPrefixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r usersQueryLastNameString) HasSuffix(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r usersQueryLastNameString) HasSuffixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type usersQueryEmailString struct{}

// Set the required value of Email
func (r usersQueryEmailString) Set(value string) usersWithPrismaEmailSetParam {

	return usersWithPrismaEmailSetParam{
		data: builder.Field{
			Name:  "email",
			Value: value,
		},
	}

}

// Set the optional value of Email dynamically
func (r usersQueryEmailString) SetIfPresent(value *string) usersWithPrismaEmailSetParam {
	if value == nil {
		return usersWithPrismaEmailSetParam{}
	}

	return r.Set(*value)
}

func (r usersQueryEmailString) Equals(value string) usersWithPrismaEmailEqualsParam {

	return usersWithPrismaEmailEqualsParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) EqualsIfPresent(value *string) usersWithPrismaEmailEqualsParam {
	if value == nil {
		return usersWithPrismaEmailEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryEmailString) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "email",
			Value: direction,
		},
	}
}

func (r usersQueryEmailString) In(value []string) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryEmailString) InIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.In(value)
}

func (r usersQueryEmailString) NotIn(value []string) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryEmailString) NotInIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usersQueryEmailString) Lt(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) LtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usersQueryEmailString) Lte(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) LteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usersQueryEmailString) Gt(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) GtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usersQueryEmailString) Gte(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) GteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usersQueryEmailString) Contains(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) ContainsIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Contains(*value)
}

func (r usersQueryEmailString) StartsWith(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) StartsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r usersQueryEmailString) EndsWith(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) EndsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r usersQueryEmailString) Mode(value QueryMode) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) ModeIfPresent(value *QueryMode) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Mode(*value)
}

func (r usersQueryEmailString) Not(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) NotIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r usersQueryEmailString) HasPrefix(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r usersQueryEmailString) HasPrefixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r usersQueryEmailString) HasSuffix(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r usersQueryEmailString) HasSuffixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type usersQueryPasswordString struct{}

// Set the required value of Password
func (r usersQueryPasswordString) Set(value string) usersWithPrismaPasswordSetParam {

	return usersWithPrismaPasswordSetParam{
		data: builder.Field{
			Name:  "password",
			Value: value,
		},
	}

}

// Set the optional value of Password dynamically
func (r usersQueryPasswordString) SetIfPresent(value *string) usersWithPrismaPasswordSetParam {
	if value == nil {
		return usersWithPrismaPasswordSetParam{}
	}

	return r.Set(*value)
}

func (r usersQueryPasswordString) Equals(value string) usersWithPrismaPasswordEqualsParam {

	return usersWithPrismaPasswordEqualsParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordString) EqualsIfPresent(value *string) usersWithPrismaPasswordEqualsParam {
	if value == nil {
		return usersWithPrismaPasswordEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryPasswordString) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "password",
			Value: direction,
		},
	}
}

func (r usersQueryPasswordString) In(value []string) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryPasswordString) InIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.In(value)
}

func (r usersQueryPasswordString) NotIn(value []string) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryPasswordString) NotInIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usersQueryPasswordString) Lt(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordString) LtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usersQueryPasswordString) Lte(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordString) LteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usersQueryPasswordString) Gt(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordString) GtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usersQueryPasswordString) Gte(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordString) GteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usersQueryPasswordString) Contains(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordString) ContainsIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Contains(*value)
}

func (r usersQueryPasswordString) StartsWith(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordString) StartsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r usersQueryPasswordString) EndsWith(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordString) EndsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r usersQueryPasswordString) Mode(value QueryMode) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordString) ModeIfPresent(value *QueryMode) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Mode(*value)
}

func (r usersQueryPasswordString) Not(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryPasswordString) NotIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r usersQueryPasswordString) HasPrefix(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r usersQueryPasswordString) HasPrefixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r usersQueryPasswordString) HasSuffix(value string) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r usersQueryPasswordString) HasSuffixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type usersQueryAccessLevelInt struct{}

// Set the required value of AccessLevel
func (r usersQueryAccessLevelInt) Set(value int) usersSetParam {

	return usersSetParam{
		data: builder.Field{
			Name:  "accessLevel",
			Value: value,
		},
	}

}

// Set the optional value of AccessLevel dynamically
func (r usersQueryAccessLevelInt) SetIfPresent(value *int) usersSetParam {
	if value == nil {
		return usersSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of AccessLevel
func (r usersQueryAccessLevelInt) Increment(value int) usersSetParam {

	return usersSetParam{
		data: builder.Field{
			Name: "accessLevel",
			Fields: []builder.Field{
				builder.Field{
					Name: "increment",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryAccessLevelInt) IncrementIfPresent(value *int) usersSetParam {
	if value == nil {
		return usersSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of AccessLevel
func (r usersQueryAccessLevelInt) Decrement(value int) usersSetParam {

	return usersSetParam{
		data: builder.Field{
			Name: "accessLevel",
			Fields: []builder.Field{
				builder.Field{
					Name: "decrement",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryAccessLevelInt) DecrementIfPresent(value *int) usersSetParam {
	if value == nil {
		return usersSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of AccessLevel
func (r usersQueryAccessLevelInt) Multiply(value int) usersSetParam {

	return usersSetParam{
		data: builder.Field{
			Name: "accessLevel",
			Fields: []builder.Field{
				builder.Field{
					Name: "multiply",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryAccessLevelInt) MultiplyIfPresent(value *int) usersSetParam {
	if value == nil {
		return usersSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of AccessLevel
func (r usersQueryAccessLevelInt) Divide(value int) usersSetParam {

	return usersSetParam{
		data: builder.Field{
			Name: "accessLevel",
			Fields: []builder.Field{
				builder.Field{
					Name: "divide",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryAccessLevelInt) DivideIfPresent(value *int) usersSetParam {
	if value == nil {
		return usersSetParam{}
	}
	return r.Divide(*value)
}

func (r usersQueryAccessLevelInt) Equals(value int) usersWithPrismaAccessLevelEqualsParam {

	return usersWithPrismaAccessLevelEqualsParam{
		data: builder.Field{
			Name: "accessLevel",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryAccessLevelInt) EqualsIfPresent(value *int) usersWithPrismaAccessLevelEqualsParam {
	if value == nil {
		return usersWithPrismaAccessLevelEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryAccessLevelInt) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "accessLevel",
			Value: direction,
		},
	}
}

func (r usersQueryAccessLevelInt) In(value []int) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "accessLevel",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryAccessLevelInt) InIfPresent(value []int) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.In(value)
}

func (r usersQueryAccessLevelInt) NotIn(value []int) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "accessLevel",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryAccessLevelInt) NotInIfPresent(value []int) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usersQueryAccessLevelInt) Lt(value int) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "accessLevel",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryAccessLevelInt) LtIfPresent(value *int) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usersQueryAccessLevelInt) Lte(value int) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "accessLevel",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryAccessLevelInt) LteIfPresent(value *int) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usersQueryAccessLevelInt) Gt(value int) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "accessLevel",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryAccessLevelInt) GtIfPresent(value *int) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usersQueryAccessLevelInt) Gte(value int) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "accessLevel",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryAccessLevelInt) GteIfPresent(value *int) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usersQueryAccessLevelInt) Not(value int) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "accessLevel",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryAccessLevelInt) NotIfPresent(value *int) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r usersQueryAccessLevelInt) LT(value int) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "accessLevel",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r usersQueryAccessLevelInt) LTIfPresent(value *int) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r usersQueryAccessLevelInt) LTE(value int) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "accessLevel",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r usersQueryAccessLevelInt) LTEIfPresent(value *int) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r usersQueryAccessLevelInt) GT(value int) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "accessLevel",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r usersQueryAccessLevelInt) GTIfPresent(value *int) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r usersQueryAccessLevelInt) GTE(value int) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "accessLevel",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r usersQueryAccessLevelInt) GTEIfPresent(value *int) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.GTE(*value)
}

// base struct
type usersQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r usersQueryCreatedAtDateTime) Set(value DateTime) usersSetParam {

	return usersSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r usersQueryCreatedAtDateTime) SetIfPresent(value *DateTime) usersSetParam {
	if value == nil {
		return usersSetParam{}
	}

	return r.Set(*value)
}

func (r usersQueryCreatedAtDateTime) Equals(value DateTime) usersWithPrismaCreatedAtEqualsParam {

	return usersWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) usersWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return usersWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryCreatedAtDateTime) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r usersQueryCreatedAtDateTime) In(value []DateTime) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryCreatedAtDateTime) InIfPresent(value []DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.In(value)
}

func (r usersQueryCreatedAtDateTime) NotIn(value []DateTime) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usersQueryCreatedAtDateTime) Lt(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryCreatedAtDateTime) LtIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usersQueryCreatedAtDateTime) Lte(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryCreatedAtDateTime) LteIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usersQueryCreatedAtDateTime) Gt(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryCreatedAtDateTime) GtIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usersQueryCreatedAtDateTime) Gte(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryCreatedAtDateTime) GteIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usersQueryCreatedAtDateTime) Not(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryCreatedAtDateTime) NotIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r usersQueryCreatedAtDateTime) Before(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r usersQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r usersQueryCreatedAtDateTime) After(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r usersQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r usersQueryCreatedAtDateTime) BeforeEquals(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r usersQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r usersQueryCreatedAtDateTime) AfterEquals(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r usersQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type usersQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r usersQueryUpdatedAtDateTime) Set(value DateTime) usersSetParam {

	return usersSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r usersQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) usersSetParam {
	if value == nil {
		return usersSetParam{}
	}

	return r.Set(*value)
}

func (r usersQueryUpdatedAtDateTime) Equals(value DateTime) usersWithPrismaUpdatedAtEqualsParam {

	return usersWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) usersWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return usersWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryUpdatedAtDateTime) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r usersQueryUpdatedAtDateTime) In(value []DateTime) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryUpdatedAtDateTime) InIfPresent(value []DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.In(value)
}

func (r usersQueryUpdatedAtDateTime) NotIn(value []DateTime) usersDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r usersQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usersQueryUpdatedAtDateTime) Lt(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usersQueryUpdatedAtDateTime) Lte(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usersQueryUpdatedAtDateTime) Gt(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usersQueryUpdatedAtDateTime) Gte(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usersQueryUpdatedAtDateTime) Not(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r usersQueryUpdatedAtDateTime) Before(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r usersQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r usersQueryUpdatedAtDateTime) After(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r usersQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r usersQueryUpdatedAtDateTime) BeforeEquals(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r usersQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r usersQueryUpdatedAtDateTime) AfterEquals(value DateTime) usersDefaultParam {

	return usersDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r usersQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.AfterEquals(*value)
}
